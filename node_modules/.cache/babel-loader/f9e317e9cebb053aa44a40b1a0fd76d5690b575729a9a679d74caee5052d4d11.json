{"ast":null,"code":"var path = require('path');\nvar fs = require('fs');\nvar assert = require(\"assert\");\n\n// file.mkdirs\n//\n// Given a path to a directory, create it, and all the intermediate directories\n// as well\n// \n// @path: the path to create\n// @mode: the file mode to create the directory with:\n//    ex: file.mkdirs(\"/tmp/dir\", 755, function () {})\n// @callback: called when finished.\nexports.mkdirs = function (_path, mode, callback) {\n  _path = exports.path.abspath(_path);\n  var dirs = _path.split(path.sep);\n  var walker = [dirs.shift()];\n\n  // walk\n  // @ds:  A list of directory names\n  // @acc: An accumulator of walked dirs\n  // @m:   The mode\n  // @cb:  The callback\n  var walk = function (ds, acc, m, cb) {\n    if (ds.length > 0) {\n      var d = ds.shift();\n      acc.push(d);\n      var dir = acc.join(path.sep);\n\n      // look for dir on the fs, if it doesn't exist then create it, and \n      // continue our walk, otherwise if it's a file, we have a name\n      // collision, so exit.\n      fs.stat(dir, function (err, stat) {\n        // if the directory doesn't exist then create it\n        if (err) {\n          // 2 means it's wasn't there\n          if (err.errno == 2 || err.errno == 34) {\n            fs.mkdir(dir, m, function (erro) {\n              if (erro && erro.errno != 17 && erro.errno != 34) {\n                return cb(erro);\n              } else {\n                return walk(ds, acc, m, cb);\n              }\n            });\n          } else {\n            return cb(err);\n          }\n        } else {\n          if (stat.isDirectory()) {\n            return walk(ds, acc, m, cb);\n          } else {\n            return cb(new Error(\"Failed to mkdir \" + dir + \": File exists\\n\"));\n          }\n        }\n      });\n    } else {\n      return cb();\n    }\n  };\n  return walk(dirs, walker, mode, callback);\n};\n\n// file.mkdirsSync\n//\n// Synchronus version of file.mkdirs\n//\n// Given a path to a directory, create it, and all the intermediate directories\n// as well\n// \n// @path: the path to create\n// @mode: the file mode to create the directory with:\n//    ex: file.mkdirs(\"/tmp/dir\", 755, function () {})\nexports.mkdirsSync = function (_path, mode) {\n  if (_path[0] !== path.sep) {\n    _path = path.join(process.cwd(), _path);\n  }\n  var dirs = _path.split(path.sep);\n  var walker = [dirs.shift()];\n  dirs.reduce(function (acc, d) {\n    acc.push(d);\n    var dir = acc.join(path.sep);\n    try {\n      var stat = fs.statSync(dir);\n      if (!stat.isDirectory()) {\n        throw \"Failed to mkdir \" + dir + \": File exists\";\n      }\n    } catch (err) {\n      fs.mkdirSync(dir, mode);\n    }\n    return acc;\n  }, walker);\n};\n\n// file.walk\n//\n// Given a path to a directory, walk the fs below that directory\n// \n// @start: the path to startat\n// @callback: called for each new directory we enter\n//    ex: file.walk(\"/tmp\", function(error, path, dirs, name) {})\n//\n//    path is the current directory we're in\n//    dirs is the list of directories below it\n//    names is the list of files in it\n//\nexports.walk = function (start, callback) {\n  fs.lstat(start, function (err, stat) {\n    if (err) {\n      return callback(err);\n    }\n    if (stat.isDirectory()) {\n      fs.readdir(start, function (err, files) {\n        var coll = files.reduce(function (acc, i) {\n          var abspath = path.join(start, i);\n          if (fs.statSync(abspath).isDirectory()) {\n            exports.walk(abspath, callback);\n            acc.dirs.push(abspath);\n          } else {\n            acc.names.push(abspath);\n          }\n          return acc;\n        }, {\n          \"names\": [],\n          \"dirs\": []\n        });\n        return callback(null, start, coll.dirs, coll.names);\n      });\n    } else {\n      return callback(new Error(\"path: \" + start + \" is not a directory\"));\n    }\n  });\n};\n\n// file.walkSync\n//\n// Synchronus version of file.walk\n//\n// Given a path to a directory, walk the fs below that directory\n// \n// @start: the path to startat\n// @callback: called for each new directory we enter\n//    ex: file.walk(\"/tmp\", function(error, path, dirs, name) {})\n//\n//    path is the current directory we're in\n//    dirs is the list of directories below it\n//    names is the list of files in it\n//\nexports.walkSync = function (start, callback) {\n  var stat = fs.statSync(start);\n  if (stat.isDirectory()) {\n    var filenames = fs.readdirSync(start);\n    var coll = filenames.reduce(function (acc, name) {\n      var abspath = path.join(start, name);\n      if (fs.statSync(abspath).isDirectory()) {\n        acc.dirs.push(name);\n      } else {\n        acc.names.push(name);\n      }\n      return acc;\n    }, {\n      \"names\": [],\n      \"dirs\": []\n    });\n    callback(start, coll.dirs, coll.names);\n    coll.dirs.forEach(function (d) {\n      var abspath = path.join(start, d);\n      exports.walkSync(abspath, callback);\n    });\n  } else {\n    throw new Error(\"path: \" + start + \" is not a directory\");\n  }\n};\nexports.path = {};\nexports.path.abspath = function (to) {\n  var from;\n  switch (to.charAt(0)) {\n    case \"~\":\n      from = process.env.HOME;\n      to = to.substr(1);\n      break;\n    case path.sep:\n      from = \"\";\n      break;\n    default:\n      from = process.cwd();\n      break;\n  }\n  return path.join(from, to);\n};\nexports.path.relativePath = function (base, compare) {\n  base = base.split(path.sep);\n  compare = compare.split(path.sep);\n  if (base[0] == \"\") {\n    base.shift();\n  }\n  if (compare[0] == \"\") {\n    compare.shift();\n  }\n  var l = compare.length;\n  for (var i = 0; i < l; i++) {\n    if (!base[i] || base[i] != compare[i]) {\n      return compare.slice(i).join(path.sep);\n    }\n  }\n  return \"\";\n};\nexports.path.join = function (head, tail) {\n  if (head == \"\") {\n    return tail;\n  } else {\n    return path.join(head, tail);\n  }\n};","map":{"version":3,"names":["path","require","fs","assert","exports","mkdirs","_path","mode","callback","abspath","dirs","split","sep","walker","shift","walk","ds","acc","m","cb","length","d","push","dir","join","stat","err","errno","mkdir","erro","isDirectory","Error","mkdirsSync","process","cwd","reduce","statSync","mkdirSync","start","lstat","readdir","files","coll","i","names","walkSync","filenames","readdirSync","name","forEach","to","from","charAt","env","HOME","substr","relativePath","base","compare","l","slice","head","tail"],"sources":["C:/Users/Syahrul/PKM/test-react/portfolio-alpha/node_modules/file/lib/file.js"],"sourcesContent":["var path = require('path');\nvar fs = require('fs');\nvar assert = require(\"assert\");\n\n// file.mkdirs\n//\n// Given a path to a directory, create it, and all the intermediate directories\n// as well\n// \n// @path: the path to create\n// @mode: the file mode to create the directory with:\n//    ex: file.mkdirs(\"/tmp/dir\", 755, function () {})\n// @callback: called when finished.\nexports.mkdirs = function (_path, mode, callback) {\n  _path = exports.path.abspath(_path);\n\n  var dirs = _path.split(path.sep);\n  var walker = [dirs.shift()];\n\n  // walk\n  // @ds:  A list of directory names\n  // @acc: An accumulator of walked dirs\n  // @m:   The mode\n  // @cb:  The callback\n  var walk = function (ds, acc, m, cb) {\n    if (ds.length > 0) {\n      var d = ds.shift();\n\n      acc.push(d);\n      var dir = acc.join(path.sep);\n\n      // look for dir on the fs, if it doesn't exist then create it, and \n      // continue our walk, otherwise if it's a file, we have a name\n      // collision, so exit.\n      fs.stat(dir, function (err, stat) {\n        // if the directory doesn't exist then create it\n        if (err) {\n          // 2 means it's wasn't there\n          if (err.errno == 2 || err.errno == 34) {\n            fs.mkdir(dir, m, function (erro) {\n              if (erro && erro.errno != 17 && erro.errno != 34) {\n                return cb(erro);\n              } else {\n                return walk(ds, acc, m, cb);\n              }\n            });\n          } else {\n            return cb(err);\n          }\n        } else {\n          if (stat.isDirectory()) {\n            return walk(ds, acc, m, cb);\n          } else {\n            return cb(new Error(\"Failed to mkdir \" + dir + \": File exists\\n\"));\n          }\n        }\n      });\n    } else {\n      return cb();\n    }\n  };\n  return walk(dirs, walker, mode, callback);\n};\n\n// file.mkdirsSync\n//\n// Synchronus version of file.mkdirs\n//\n// Given a path to a directory, create it, and all the intermediate directories\n// as well\n// \n// @path: the path to create\n// @mode: the file mode to create the directory with:\n//    ex: file.mkdirs(\"/tmp/dir\", 755, function () {})\nexports.mkdirsSync = function (_path, mode) {\n  if (_path[0] !== path.sep) {\n    _path = path.join(process.cwd(), _path)\n  }\n\n  var dirs = _path.split(path.sep);\n  var walker = [dirs.shift()];\n\n  dirs.reduce(function (acc, d) {\n    acc.push(d);\n    var dir = acc.join(path.sep);\n    \n    try {\n      var stat = fs.statSync(dir);\n      if (!stat.isDirectory()) {\n        throw \"Failed to mkdir \" + dir + \": File exists\";\n      }\n    } catch (err) {\n      fs.mkdirSync(dir, mode);\n    }\n    return acc;\n  }, walker);\n};\n\n// file.walk\n//\n// Given a path to a directory, walk the fs below that directory\n// \n// @start: the path to startat\n// @callback: called for each new directory we enter\n//    ex: file.walk(\"/tmp\", function(error, path, dirs, name) {})\n//\n//    path is the current directory we're in\n//    dirs is the list of directories below it\n//    names is the list of files in it\n//\nexports.walk = function (start, callback) {\n  fs.lstat(start, function (err, stat) {\n    if (err) { return callback(err) }\n    if (stat.isDirectory()) {\n\n      fs.readdir(start, function (err, files) {\n        var coll = files.reduce(function (acc, i) {\n          var abspath = path.join(start, i);\n\n          if (fs.statSync(abspath).isDirectory()) {\n            exports.walk(abspath, callback);\n            acc.dirs.push(abspath);\n          } else {\n            acc.names.push(abspath);\n          }\n\n          return acc;\n        }, {\"names\": [], \"dirs\": []});\n\n        return callback(null, start, coll.dirs, coll.names);\n      });\n    } else {\n      return callback(new Error(\"path: \" + start + \" is not a directory\"));\n    }\n  });\n};\n\n// file.walkSync\n//\n// Synchronus version of file.walk\n//\n// Given a path to a directory, walk the fs below that directory\n// \n// @start: the path to startat\n// @callback: called for each new directory we enter\n//    ex: file.walk(\"/tmp\", function(error, path, dirs, name) {})\n//\n//    path is the current directory we're in\n//    dirs is the list of directories below it\n//    names is the list of files in it\n//\nexports.walkSync = function (start, callback) {\n  var stat = fs.statSync(start);\n\n  if (stat.isDirectory()) {\n    var filenames = fs.readdirSync(start);\n\n    var coll = filenames.reduce(function (acc, name) {\n      var abspath = path.join(start, name);\n\n      if (fs.statSync(abspath).isDirectory()) {\n        acc.dirs.push(name);\n      } else {\n        acc.names.push(name);\n      }\n\n      return acc;\n    }, {\"names\": [], \"dirs\": []});\n\n    callback(start, coll.dirs, coll.names);\n\n    coll.dirs.forEach(function (d) {\n      var abspath = path.join(start, d);\n      exports.walkSync(abspath, callback);\n    });\n\n  } else {\n    throw new Error(\"path: \" + start + \" is not a directory\");\n  }\n};\n\nexports.path = {};\n\nexports.path.abspath = function (to) {\n  var from;\n  switch (to.charAt(0)) {\n    case \"~\": from = process.env.HOME; to = to.substr(1); break\n    case path.sep: from = \"\"; break\n    default : from = process.cwd(); break\n  }\n  return path.join(from, to);\n}\n\nexports.path.relativePath = function (base, compare) {\n  base = base.split(path.sep);\n  compare = compare.split(path.sep);\n\n  if (base[0] == \"\") {\n    base.shift();\n  }\n\n  if (compare[0] == \"\") {\n    compare.shift();\n  }\n\n  var l = compare.length;\n\n  for (var i = 0; i < l; i++) {\n    if (!base[i] || (base[i] != compare[i])) {\n      return compare.slice(i).join(path.sep);\n    }\n  }\n\n  return \"\"\n};\n\nexports.path.join = function (head, tail) {\n  if (head == \"\") {\n    return tail;\n  } else {\n    return path.join(head, tail);\n  }\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}